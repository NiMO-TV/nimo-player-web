(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.NimoTV = {}));
}(this, (function (exports) { 'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var EMessageId = {
    DISPATCH_PLAYER_EVENT: 10001 // Dispatch player events (eg: ended)

  };
  var EBusinessMessageId = {
    INVOKE_PLAYER_PLAY: 3001,
    // Player
    INVOKE_PLAYER_PAUSE: 3002,
    // Pause
    INVOKE_PLAYER_GET_PLAYER_STATE: 3003,
    // Get Player State
    INVOKE_PLAYER_MUTE: 3004 // Mute

  };

  var domain; // This constructor is used to store event handlers. Instantiating this is
  // faster than explicitly calling `Object.create(null)` to get a "clean" empty
  // object (tested with v8 v4.9).

  function EventHandlers() {}

  EventHandlers.prototype = Object.create(null);

  function EventEmitter() {
    EventEmitter.init.call(this);
  }
  // require('events') === require('events').EventEmitter

  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.usingDomains = false;
  EventEmitter.prototype.domain = undefined;
  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.

  EventEmitter.defaultMaxListeners = 10;

  EventEmitter.init = function () {
    this.domain = null;

    if (EventEmitter.usingDomains) {
      // if there is an active domain, then attach to it.
      if (domain.active ) ;
    }

    if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    }

    this._maxListeners = this._maxListeners || undefined;
  }; // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.


  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || isNaN(n)) throw new TypeError('"n" argument must be a positive number');
    this._maxListeners = n;
    return this;
  };

  function $getMaxListeners(that) {
    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }

  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return $getMaxListeners(this);
  }; // These standalone emit* functions are used to optimize calling of event
  // handlers for fast cases because emit() itself often has a variable number of
  // arguments and can be deoptimized because of that. These functions always have
  // the same number of arguments and thus do not get deoptimized, so the code
  // inside them can execute faster.


  function emitNone(handler, isFn, self) {
    if (isFn) handler.call(self);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);

      for (var i = 0; i < len; ++i) listeners[i].call(self);
    }
  }

  function emitOne(handler, isFn, self, arg1) {
    if (isFn) handler.call(self, arg1);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);

      for (var i = 0; i < len; ++i) listeners[i].call(self, arg1);
    }
  }

  function emitTwo(handler, isFn, self, arg1, arg2) {
    if (isFn) handler.call(self, arg1, arg2);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);

      for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2);
    }
  }

  function emitThree(handler, isFn, self, arg1, arg2, arg3) {
    if (isFn) handler.call(self, arg1, arg2, arg3);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);

      for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2, arg3);
    }
  }

  function emitMany(handler, isFn, self, args) {
    if (isFn) handler.apply(self, args);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);

      for (var i = 0; i < len; ++i) listeners[i].apply(self, args);
    }
  }

  EventEmitter.prototype.emit = function emit(type) {
    var er, handler, len, args, i, events, domain;
    var doError = type === 'error';
    events = this._events;
    if (events) doError = doError && events.error == null;else if (!doError) return false;
    domain = this.domain; // If there is no 'error' event listener then throw.

    if (doError) {
      er = arguments[1];

      if (domain) {
        if (!er) er = new Error('Uncaught, unspecified "error" event');
        er.domainEmitter = this;
        er.domain = domain;
        er.domainThrown = false;
        domain.emit('error', er);
      } else if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }

      return false;
    }

    handler = events[type];
    if (!handler) return false;
    var isFn = typeof handler === 'function';
    len = arguments.length;

    switch (len) {
      // fast cases
      case 1:
        emitNone(handler, isFn, this);
        break;

      case 2:
        emitOne(handler, isFn, this, arguments[1]);
        break;

      case 3:
        emitTwo(handler, isFn, this, arguments[1], arguments[2]);
        break;

      case 4:
        emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
        break;
      // slower

      default:
        args = new Array(len - 1);

        for (i = 1; i < len; i++) args[i - 1] = arguments[i];

        emitMany(handler, isFn, this, args);
    }
    return true;
  };

  function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
    events = target._events;

    if (!events) {
      events = target._events = new EventHandlers();
      target._eventsCount = 0;
    } else {
      // To avoid recursion in the case that type === "newListener"! Before
      // adding it to the listeners, first emit "newListener".
      if (events.newListener) {
        target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
        // this._events to be assigned to a new object

        events = target._events;
      }

      existing = events[type];
    }

    if (!existing) {
      // Optimize the case of one listener. Don't need the extra array object.
      existing = events[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === 'function') {
        // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [listener, existing] : [existing, listener];
      } else {
        // If we've already got an array, just append.
        if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
      } // Check for listener leak


      if (!existing.warned) {
        m = $getMaxListeners(target);

        if (m && m > 0 && existing.length > m) {
          existing.warned = true;
          var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + type + ' listeners added. ' + 'Use emitter.setMaxListeners() to increase limit');
          w.name = 'MaxListenersExceededWarning';
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          emitWarning(w);
        }
      }
    }

    return target;
  }

  function emitWarning(e) {
    typeof console.warn === 'function' ? console.warn(e) : console.log(e);
  }

  EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
  };

  EventEmitter.prototype.on = EventEmitter.prototype.addListener;

  EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
  };

  function _onceWrap(target, type, listener) {
    var fired = false;

    function g() {
      target.removeListener(type, g);

      if (!fired) {
        fired = true;
        listener.apply(target, arguments);
      }
    }

    g.listener = listener;
    return g;
  }

  EventEmitter.prototype.once = function once(type, listener) {
    if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };

  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
  }; // emits a 'removeListener' event iff the listener was removed


  EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events, position, i, originalListener;
    if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
    events = this._events;
    if (!events) return this;
    list = events[type];
    if (!list) return this;

    if (list === listener || list.listener && list.listener === listener) {
      if (--this._eventsCount === 0) this._events = new EventHandlers();else {
        delete events[type];
        if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
      }
    } else if (typeof list !== 'function') {
      position = -1;

      for (i = list.length; i-- > 0;) {
        if (list[i] === listener || list[i].listener && list[i].listener === listener) {
          originalListener = list[i].listener;
          position = i;
          break;
        }
      }

      if (position < 0) return this;

      if (list.length === 1) {
        list[0] = undefined;

        if (--this._eventsCount === 0) {
          this._events = new EventHandlers();
          return this;
        } else {
          delete events[type];
        }
      } else {
        spliceOne(list, position);
      }

      if (events.removeListener) this.emit('removeListener', type, originalListener || listener);
    }

    return this;
  };

  EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events;
    events = this._events;
    if (!events) return this; // not listening for removeListener, no need to emit

    if (!events.removeListener) {
      if (arguments.length === 0) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      } else if (events[type]) {
        if (--this._eventsCount === 0) this._events = new EventHandlers();else delete events[type];
      }

      return this;
    } // emit removeListener for all listeners on all events


    if (arguments.length === 0) {
      var keys = Object.keys(events);

      for (var i = 0, key; i < keys.length; ++i) {
        key = keys[i];
        if (key === 'removeListener') continue;
        this.removeAllListeners(key);
      }

      this.removeAllListeners('removeListener');
      this._events = new EventHandlers();
      this._eventsCount = 0;
      return this;
    }

    listeners = events[type];

    if (typeof listeners === 'function') {
      this.removeListener(type, listeners);
    } else if (listeners) {
      // LIFO order
      do {
        this.removeListener(type, listeners[listeners.length - 1]);
      } while (listeners[0]);
    }

    return this;
  };

  EventEmitter.prototype.listeners = function listeners(type) {
    var evlistener;
    var ret;
    var events = this._events;
    if (!events) ret = [];else {
      evlistener = events[type];
      if (!evlistener) ret = [];else if (typeof evlistener === 'function') ret = [evlistener.listener || evlistener];else ret = unwrapListeners(evlistener);
    }
    return ret;
  };

  EventEmitter.listenerCount = function (emitter, type) {
    if (typeof emitter.listenerCount === 'function') {
      return emitter.listenerCount(type);
    } else {
      return listenerCount.call(emitter, type);
    }
  };

  EventEmitter.prototype.listenerCount = listenerCount;

  function listenerCount(type) {
    var events = this._events;

    if (events) {
      var evlistener = events[type];

      if (typeof evlistener === 'function') {
        return 1;
      } else if (evlistener) {
        return evlistener.length;
      }
    }

    return 0;
  }

  EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  }; // About 1.5x faster than the two-arg version of Array#splice().


  function spliceOne(list, index) {
    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) list[i] = list[k];

    list.pop();
  }

  function arrayClone(arr, i) {
    var copy = new Array(i);

    while (i--) copy[i] = arr[i];

    return copy;
  }

  function unwrapListeners(arr) {
    var ret = new Array(arr.length);

    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }

    return ret;
  }

  /* eslint-disable no-param-reassign */

  var eventful = function eventful(target) {
    var ee = new EventEmitter();

    target.on = function (event, listener) {
      if (!listener) {
        return;
      }

      ee.on(event, listener);
    };

    target.off = function (event, listener) {
      if (!listener) {
        return;
      }

      ee.removeListener(event, listener);
    };

    target.once = function (event, listener) {
      if (!listener) {
        return;
      }

      ee.once(event, listener);
    };

    target.emit = function () {
      ee.emit.apply(ee, arguments);
    };

    target.trigger = target.emit;
  };

  function addUrlParams(url) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!params || params === {}) {
      return url;
    }

    var urlArr = url.split('?');
    var paramsKey = Object.keys(params);
    var reg = new RegExp("(".concat(paramsKey.join('|'), ")=(\\w|.)+"));
    var restParams = typeof urlArr[1] !== 'undefined' ? urlArr[1].split('&').filter(function (item) {
      return !reg.test(item);
    }) : [];
    var resultParams = [].concat(_toConsumableArray(restParams), _toConsumableArray(paramsKey.filter(function (k) {
      return params[k] !== undefined;
    }).map(function (k) {
      return "".concat(k, "=").concat(params[k]);
    })));
    return "".concat(urlArr[0]).concat(Array.isArray(resultParams) && resultParams.length > 0 ? "?".concat(resultParams.join('&')) : '');
  }

  var Player = /*#__PURE__*/function () {
    _createClass(Player, [{
      key: "containerId",
      set: function set(containerId) {
        this._containerId = containerId;
      },
      get: function get() {
        if (this._containerId) {
          return this._containerId;
        } else {
          throw new ReferenceError('this._containerId is not defined.');
        }
      }
    }, {
      key: "container$",
      set: function set(container$) {
        this._container$ = container$;
      },
      get: function get() {
        if (this._container$) {
          return this._container$;
        } else {
          throw new ReferenceError('this._container$ is not defined.');
        }
      }
    }]);

    function Player(containerId, _config) {
      var _this = this;

      _classCallCheck(this, Player);

      _defineProperty(this, "_containerId", void 0);

      _defineProperty(this, "_container$", void 0);

      _defineProperty(this, "targetOrigin", 'https://www.nimo.tv');

      _defineProperty(this, "handleWndMessage", function (evt) {
        var evtData = evt.data;

        var _ref = evtData || {},
            messageId = _ref.messageId,
            _uuid = _ref._uuid,
            config = _ref.data;

        if (_uuid !== _this.containerId) {
          return;
        }

        if (messageId === EMessageId.DISPATCH_PLAYER_EVENT) {
          var _ref2 = config || {},
              eventType = _ref2.eventType,
              data = _ref2.data;

          _this.emit(eventType, data);
        }
      });

      _defineProperty(this, "play", function () {
        _this.sendBizMsg(EBusinessMessageId.INVOKE_PLAYER_PLAY);
      });

      _defineProperty(this, "pause", function () {
        _this.sendBizMsg(EBusinessMessageId.INVOKE_PLAYER_PAUSE);
      });

      _defineProperty(this, "destroy", function () {
        if (_this.player$ && _this.player$.parentNode) {
          _this.player$.parentNode.removeChild(_this.player$);
        }
      });

      _defineProperty(this, "getState", function () {
        return new Promise(function (resolve, reject) {
          _this.handleGetState = function (data) {
            resolve(data);

            _this.off(Player.STATE, _this.handleGetState);
          };

          _this.on(Player.STATE, _this.handleGetState);

          _this.sendBizMsg(EBusinessMessageId.INVOKE_PLAYER_GET_PLAYER_STATE);
        });
      });

      _defineProperty(this, "muted", function (muted) {
        _this.sendBizMsg(EBusinessMessageId.INVOKE_PLAYER_MUTE, {
          muted: muted
        });
      });

      eventful(this);
      this.containerId = containerId;
      this.container$ = document.getElementById(this.containerId);
      this.player$ = this._createPlayer(_config);
      this.container$.appendChild(this.player$);
      this.init();
    }

    _createClass(Player, [{
      key: "init",
      value: function init() {
        window.addEventListener('message', this.handleWndMessage);
      }
    }, {
      key: "dispose",
      value: function dispose() {
        window.removeEventListener('message', this.handleWndMessage);

        if (this.handleGetState) {
          this.off(Player.STATE, this.handleGetState);
        }

        this.player$ = null;
        this.container$ = null;
        this.containerId = null;
      }
    }, {
      key: "sendBizMsg",
      value: function sendBizMsg(messageId, data) {
        this._send('biz_msg', {
          messageId: messageId,
          data: data
        });
      }
    }, {
      key: "_send",
      value: function _send(type, data) {
        var otherWindow = this.player$.contentWindow;

        if (otherWindow && typeof otherWindow.postMessage === 'function') {
          otherWindow.postMessage(_objectSpread2({}, data, {
            type: type,
            _uuid: this.containerId
          }), this.targetOrigin);
        }
      }
    }, {
      key: "_createPlayer",
      value: function _createPlayer(config) {
        var _ref3 = config || {},
            width = _ref3.width,
            height = _ref3.height,
            resourceId = _ref3.resourceId,
            lang = _ref3.lang,
            autoplay = _ref3.autoplay,
            muted = _ref3.muted;

        var player$ = document.createElement('iframe');
        player$.setAttribute('src', this._getUrl(resourceId, {
          _lang: lang,
          _autoplay: autoplay,
          _muted: muted
        }));
        player$.setAttribute('width', width);
        player$.setAttribute('height', height);
        player$.setAttribute('frameborder', 0);
        player$.setAttribute('scrolling', 0);
        player$.setAttribute('allow', 'fullscreen');
        player$.setAttribute('allowfullscreen', true);
        return player$;
      }
    }, {
      key: "_getUrl",
      value: function _getUrl(resourceId, queryParams) {
        var url = "".concat(this.targetOrigin, "/embed/").concat(resourceId);

        var params = _objectSpread2({}, queryParams, {
          _uuid: this.containerId
        });

        url = addUrlParams(url, params);
        return url;
      }
    }]);

    return Player;
  }();

  _defineProperty(Player, "ENDED", 'ended');

  _defineProperty(Player, "STATE", 'getPlayerState');

  _defineProperty(Player, "PLAY", 'playing');

  _defineProperty(Player, "PAUSED", 'paused');

  _defineProperty(Player, "MUTED", 'muted');

  exports.Player = Player;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=embed-player-0.5.0.js.map
